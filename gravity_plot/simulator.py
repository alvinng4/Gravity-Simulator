import csv
import datetime
import math
from pathlib import Path
import rich.progress
import timeit
import sys


import numba as nb  # Note: nb.njit cannot works on functions inside a class
import numpy as np


class Simulator:
    # Conversion factor from km^3 s^-2 to AU^3 d^-2
    CONVERSION_FACTOR = (86400**2) / (149597870.7**3)
    # GM values (km^3 s^-2)
    # ref: https://ssd.jpl.nasa.gov/doc/Park.2021.AJ.DE440.pdf
    GM_SI = {
        "Sun": 132712440041.279419,
        "Mercury": 22031.868551,
        "Venus": 324858.592000,
        "Earth": 398600.435507,
        "Mars": 42828.375816,
        "Jupiter": 126712764.100000,
        "Saturn": 37940584.841800,
        "Uranus": 5794556.400000,
        "Neptune": 6836527.100580,
        "Moon": 4902.800118,
        "Pluto": 975.500000,
        "Ceres": 62.62890,
        "Vesta": 17.288245,
    }
    # GM values (AU^3 d^-2)
    GM = {
        "Sun": 132712440041.279419 * CONVERSION_FACTOR,
        "Mercury": 22031.868551 * CONVERSION_FACTOR,
        "Venus": 324858.592000 * CONVERSION_FACTOR,
        "Earth": 398600.435507 * CONVERSION_FACTOR,
        "Mars": 42828.375816 * CONVERSION_FACTOR,
        "Jupiter": 126712764.100000 * CONVERSION_FACTOR,
        "Saturn": 37940584.841800 * CONVERSION_FACTOR,
        "Uranus": 5794556.400000 * CONVERSION_FACTOR,
        "Neptune": 6836527.100580 * CONVERSION_FACTOR,
        "Moon": 4902.800118 * CONVERSION_FACTOR,
        "Pluto": 975.500000 * CONVERSION_FACTOR,
        "Ceres": 62.62890 * CONVERSION_FACTOR,
        "Vesta": 17.288245 * CONVERSION_FACTOR,
    }
    # Solar system masses (M_sun^-1)
    SOLAR_SYSTEM_MASSES = {
        "Sun": 1.0,
        "Mercury": GM_SI["Mercury"] / GM_SI["Sun"],
        "Venus": GM_SI["Venus"] / GM_SI["Sun"],
        "Earth": GM_SI["Earth"] / GM_SI["Sun"],
        "Mars": GM_SI["Mars"] / GM_SI["Sun"],
        "Jupiter": GM_SI["Jupiter"] / GM_SI["Sun"],
        "Saturn": GM_SI["Saturn"] / GM_SI["Sun"],
        "Uranus": GM_SI["Uranus"] / GM_SI["Sun"],
        "Neptune": GM_SI["Neptune"] / GM_SI["Sun"],
        "Moon": GM_SI["Moon"] / GM_SI["Sun"],
        "Pluto": GM_SI["Pluto"] / GM_SI["Sun"],
        "Ceres": GM_SI["Ceres"] / GM_SI["Sun"],
        "Vesta": GM_SI["Vesta"] / GM_SI["Sun"],
    }
    # Gravitational constant (kg^-1 m^3 s^-2):
    CONSTANT_G_SI = 6.67430e-11
    # Gravitational constant (M_sun^-1 AU^3 d^-2):
    CONSTANT_G = GM["Sun"]

    # Solar system position and velocities data
    # Units: AU-D
    # Coordinate center: Solar System Barycenter
    # Data dated on A.D. 2024-Jan-01 00:00:00.0000 TDB
    # Computational data generated by NASA JPL Horizons System https://ssd.jpl.nasa.gov/horizons/
    SOLAR_SYSTEM_POS = {
        "Sun": [-7.967955691533730e-03, -2.906227441573178e-03, 2.103054301547123e-04],
        "Mercury": [
            -2.825983269538632e-01,
            1.974559795958082e-01,
            4.177433558063677e-02,
        ],
        "Venus": [
            -7.232103701666379e-01,
            -7.948302026312400e-02,
            4.042871428174315e-02,
        ],
        "Earth": [-1.738192017257054e-01, 9.663245550235138e-01, 1.553901854897183e-04],
        "Mars": [-3.013262392582653e-01, -1.454029331393295e00, -2.300531433991428e-02],
        "Jupiter": [3.485202469657674e00, 3.552136904413157e00, -9.271035442798399e-02],
        "Saturn": [8.988104223143450e00, -3.719064854634689e00, -2.931937777323593e-01],
        "Uranus": [1.226302417897505e01, 1.529738792480545e01, -1.020549026883563e-01],
        "Neptune": [
            2.983501460984741e01,
            -1.793812957956852e00,
            -6.506401132254588e-01,
        ],
        "Moon": [-1.762788124769829e-01, 9.674377513177153e-01, 3.236901585768862e-04],
        "Pluto": [1.720200478843485e01, -3.034155683573043e01, -1.729127607100611e00],
        "Ceres": [-1.103880510367569e00, -2.533340440444230e00, 1.220283937721780e-01],
        "Vesta": [-8.092549658731499e-02, 2.558381434460076e00, -6.695836142398572e-02],
    }
    SOLAR_SYSTEM_VEL = {
        "Sun": [4.875094764261564e-06, -7.057133213976680e-06, -4.573453713094512e-08],
        "Mercury": [
            -2.232165900189702e-02,
            -2.157207103176252e-02,
            2.855193410495743e-04,
        ],
        "Venus": [
            2.034068201002341e-03,
            -2.020828626592994e-02,
            -3.945639843855159e-04,
        ],
        "Earth": [
            -1.723001232538228e-02,
            -2.967721342618870e-03,
            6.382125383116755e-07,
        ],
        "Mars": [1.424832259345280e-02, -1.579236181580905e-03, -3.823722796161561e-04],
        "Jupiter": [
            -5.470970658852281e-03,
            5.642487338479145e-03,
            9.896190602066252e-05,
        ],
        "Saturn": [
            1.822013845554067e-03,
            5.143470425888054e-03,
            -1.617235904887937e-04,
        ],
        "Uranus": [
            -3.097615358317413e-03,
            2.276781932345769e-03,
            4.860433222241686e-05,
        ],
        "Neptune": [
            1.676536611817232e-04,
            3.152098732861913e-03,
            -6.877501095688201e-05,
        ],
        "Moon": [
            -1.746667306153906e-02,
            -3.473438277358121e-03,
            -3.359028758606074e-05,
        ],
        "Pluto": [2.802810313667557e-03, 8.492056438614633e-04, -9.060790113327894e-04],
        "Ceres": [
            8.978653480111301e-03,
            -4.873256528198994e-03,
            -1.807162046049230e-03,
        ],
        "Vesta": [
            -1.017876585480054e-02,
            -5.452367109338154e-04,
            1.255870551153315e-03,
        ],
    }

    def __init__(self, plotter):
        self.system = plotter.system
        self.integrator = plotter.integrator
        self.tf = plotter.tf
        self.unit = plotter.unit
        self.tolerance = plotter.tolerance
        self.dt = plotter.dt
        self.G = self.CONSTANT_G

    def initialize_system(self, plotter):
        self.t0 = 0.0
        if self.integrator in ["rkf45", "dopri", "dverk", "rkf78"]:
            match self.integrator:
                case "rkf45":
                    self.order = 45
                case "dopri":
                    self.order = 54
                case "dverk":
                    self.order = 65
                case "rkf78":
                    self.order = 78

        # Read information of the customized system
        if self.system not in plotter.default_systems:
            file_path = Path(str(Path(__file__).parent) + "/customized_systems.csv")
            try:
                with open(file_path, "r") as file:
                    reader = csv.reader(file)
                    for row in reader:
                        if self.system == row[0]:
                            self.objects_count = int(row[1])
                            self.m = row[2].strip("[]")
                            self.m = np.array([float(item) for item in self.m.split(", ")])
                            state_vec = row[3].strip("[]")
                            state_vec = np.array(
                                [float(item) for item in state_vec.split(", ")]
                            )
                            x_vec = []
                            v_vec = []
                            for i in range(self.objects_count):
                                x_vec.append([state_vec[i * 3 + j] for j in range(3)])
                                v_vec.append(
                                    [
                                        state_vec[self.objects_count * 3 + i * 3 + j]
                                        for j in range(3)
                                    ]
                                )
                            self.x = np.array(x_vec)
                            self.v = np.array(v_vec)
            except FileNotFoundError:
                sys.exit("Warning: customized_systems.csv not found in gravity_plot. Terminating program.")

        else:
            # Pre-defined systems
            match self.system:
                case "circular_binary_orbit":
                    R1 = np.array([1.0, 0.0, 0.0])
                    R2 = np.array([-1.0, 0.0, 0.0])
                    V1 = np.array([0.0, 0.5, 0.0])
                    V2 = np.array([0.0, -0.5, 0.0])
                    self.x = np.array([R1, R2])
                    self.v = np.array([V1, V2])
                    self.m = [1.0 / self.G, 1.0 / self.G]
                    self.objects_count = 2

                case "eccentric_binary_orbit":
                    R1 = np.array([1.0, 0.0, 0.0])
                    R2 = np.array([-1.25, 0.0, 0.0])
                    V1 = np.array([0.0, 0.5, 0.0])
                    V2 = np.array([0.0, -0.625, 0.0])
                    self.x = np.array([R1, R2])
                    self.v = np.array([V1, V2])
                    self.m = [1.0 / self.G, 0.8 / self.G]
                    self.objects_count = 2

                case "3d_helix":
                    R1 = np.array([0.0, 0.0, -1.0])
                    R2 = np.array([-math.sqrt(3.0) / 2.0, 0.0, 0.5])
                    R3 = np.array([math.sqrt(3.0) / 2.0, 0.0, 0.5])
                    v0 = math.sqrt(1.0 / math.sqrt(3))
                    V1 = np.array([-v0, 0.5, 0.0])
                    V2 = np.array([0.5 * v0, 0.5, (math.sqrt(3.0) / 2.0) * v0])
                    V3 = np.array([0.5 * v0, 0.5, -(math.sqrt(3.0) / 2.0) * v0])
                    self.x = np.array([R1, R2, R3])
                    self.v = np.array([V1, V2, V3])
                    self.m = [1.0 / self.G, 1.0 / self.G, 1.0 / self.G]
                    self.objects_count = 3

                case "sun_earth_moon":
                    self.m = [
                        self.SOLAR_SYSTEM_MASSES["Sun"],
                        self.SOLAR_SYSTEM_MASSES["Earth"],
                        self.SOLAR_SYSTEM_MASSES["Moon"],
                    ]
                    R_CM = (
                        1
                        / np.sum(self.m)
                        * (
                            self.m[0] * np.array(self.SOLAR_SYSTEM_POS["Sun"])
                            + self.m[1] * np.array(self.SOLAR_SYSTEM_POS["Earth"])
                            + self.m[2] * np.array(self.SOLAR_SYSTEM_POS["Moon"])
                        )
                    )
                    V_CM = (
                        1
                        / np.sum(self.m)
                        * (
                            self.m[0] * np.array(self.SOLAR_SYSTEM_VEL["Sun"])
                            + self.m[1] * np.array(self.SOLAR_SYSTEM_VEL["Earth"])
                            + self.m[2] * np.array(self.SOLAR_SYSTEM_VEL["Moon"])
                        )
                    )
                    R1 = np.array(self.SOLAR_SYSTEM_POS["Sun"] - R_CM)
                    R2 = np.array(self.SOLAR_SYSTEM_POS["Earth"] - R_CM)
                    R3 = np.array(self.SOLAR_SYSTEM_POS["Moon"] - R_CM)
                    V1 = np.array(self.SOLAR_SYSTEM_VEL["Sun"] - V_CM)
                    V2 = np.array(self.SOLAR_SYSTEM_VEL["Earth"] - V_CM)
                    V3 = np.array(self.SOLAR_SYSTEM_VEL["Moon"] - V_CM)
                    self.x = np.array([R1, R2, R3])
                    self.v = np.array([V1, V2, V3])
                    self.objects_count = 3
                    self.objs_name = ["Sun", "Earth", "Moon"]

                case "figure-8":
                    R1 = np.array([0.970043, -0.24308753, 0.0])
                    R2 = np.array([-0.970043, 0.24308753, 0.0])
                    R3 = np.array([0.0, 0.0, 0.0])
                    V1 = np.array([0.466203685, 0.43236573, 0.0])
                    V2 = np.array([0.466203685, 0.43236573, 0.0])
                    V3 = np.array([-0.93240737, -0.86473146, 0.0])
                    self.x = np.array([R1, R2, R3])
                    self.v = np.array([V1, V2, V3])
                    self.m = [1.0 / self.G, 1.0 / self.G, 1.0 / self.G]
                    self.objects_count = 3

                case "pyth-3-body":
                    R1 = np.array([1.0, 3.0, 0.0])
                    R2 = np.array([-2.0, -1.0, 0.0])
                    R3 = np.array([1.0, -1.0, 0.0])
                    V1 = np.array([0.0, 0.0, 0.0])
                    V2 = np.array([0.0, 0.0, 0.0])
                    V3 = np.array([0.0, 0.0, 0.0])
                    self.x = np.array([R1, R2, R3])
                    self.v = np.array([V1, V2, V3])
                    self.m = [3.0 / self.G, 4.0 / self.G, 5.0 / self.G]
                    self.objects_count = 3

                case "solar_system":
                    self.m = [
                        self.SOLAR_SYSTEM_MASSES["Sun"],
                        self.SOLAR_SYSTEM_MASSES["Mercury"],
                        self.SOLAR_SYSTEM_MASSES["Venus"],
                        self.SOLAR_SYSTEM_MASSES["Earth"],
                        self.SOLAR_SYSTEM_MASSES["Mars"],
                        self.SOLAR_SYSTEM_MASSES["Jupiter"],
                        self.SOLAR_SYSTEM_MASSES["Saturn"],
                        self.SOLAR_SYSTEM_MASSES["Uranus"],
                        self.SOLAR_SYSTEM_MASSES["Neptune"],
                    ]
                    R_CM = (
                        1
                        / np.sum(self.m)
                        * (
                            self.m[0] * np.array(self.SOLAR_SYSTEM_POS["Sun"])
                            + self.m[1] * np.array(self.SOLAR_SYSTEM_POS["Mercury"])
                            + self.m[2] * np.array(self.SOLAR_SYSTEM_POS["Venus"])
                            + self.m[3] * np.array(self.SOLAR_SYSTEM_POS["Earth"])
                            + self.m[4] * np.array(self.SOLAR_SYSTEM_POS["Mars"])
                            + self.m[5] * np.array(self.SOLAR_SYSTEM_POS["Jupiter"])
                            + self.m[6] * np.array(self.SOLAR_SYSTEM_POS["Saturn"])
                            + self.m[7] * np.array(self.SOLAR_SYSTEM_POS["Uranus"])
                            + self.m[8] * np.array(self.SOLAR_SYSTEM_POS["Neptune"])
                        )
                    )
                    V_CM = (
                        1
                        / np.sum(self.m)
                        * (
                            self.m[0] * np.array(self.SOLAR_SYSTEM_VEL["Sun"])
                            + self.m[1] * np.array(self.SOLAR_SYSTEM_VEL["Mercury"])
                            + self.m[2] * np.array(self.SOLAR_SYSTEM_VEL["Venus"])
                            + self.m[3] * np.array(self.SOLAR_SYSTEM_VEL["Earth"])
                            + self.m[4] * np.array(self.SOLAR_SYSTEM_VEL["Mars"])
                            + self.m[5] * np.array(self.SOLAR_SYSTEM_VEL["Jupiter"])
                            + self.m[6] * np.array(self.SOLAR_SYSTEM_VEL["Saturn"])
                            + self.m[7] * np.array(self.SOLAR_SYSTEM_VEL["Uranus"])
                            + self.m[8] * np.array(self.SOLAR_SYSTEM_VEL["Neptune"])
                        )
                    )

                    R1 = np.array(self.SOLAR_SYSTEM_POS["Sun"] - R_CM)
                    R2 = np.array(self.SOLAR_SYSTEM_POS["Mercury"] - R_CM)
                    R3 = np.array(self.SOLAR_SYSTEM_POS["Venus"] - R_CM)
                    R4 = np.array(self.SOLAR_SYSTEM_POS["Earth"] - R_CM)
                    R5 = np.array(self.SOLAR_SYSTEM_POS["Mars"] - R_CM)
                    R6 = np.array(self.SOLAR_SYSTEM_POS["Jupiter"] - R_CM)
                    R7 = np.array(self.SOLAR_SYSTEM_POS["Saturn"] - R_CM)
                    R8 = np.array(self.SOLAR_SYSTEM_POS["Uranus"] - R_CM)
                    R9 = np.array(self.SOLAR_SYSTEM_POS["Neptune"] - R_CM)

                    V1 = np.array(self.SOLAR_SYSTEM_VEL["Sun"] - V_CM)
                    V2 = np.array(self.SOLAR_SYSTEM_VEL["Mercury"] - V_CM)
                    V3 = np.array(self.SOLAR_SYSTEM_VEL["Venus"] - V_CM)
                    V4 = np.array(self.SOLAR_SYSTEM_VEL["Earth"] - V_CM)
                    V5 = np.array(self.SOLAR_SYSTEM_VEL["Mars"] - V_CM)
                    V6 = np.array(self.SOLAR_SYSTEM_VEL["Jupiter"] - V_CM)
                    V7 = np.array(self.SOLAR_SYSTEM_VEL["Saturn"] - V_CM)
                    V8 = np.array(self.SOLAR_SYSTEM_VEL["Uranus"] - V_CM)
                    V9 = np.array(self.SOLAR_SYSTEM_VEL["Neptune"] - V_CM)

                    self.x = np.array([R1, R2, R3, R4, R5, R6, R7, R8, R9])
                    self.v = np.array([V1, V2, V3, V4, V5, V6, V7, V8, V9])
                    self.objects_count = 9
                    self.objs_name = [
                        "Sun",
                        "Mercury",
                        "Venus",
                        "Earth",
                        "Mars",
                        "Jupiter",
                        "Saturn",
                        "Uranus",
                        "Neptune",
                    ]

                case "solar_system_plus":
                    self.m = [
                        self.SOLAR_SYSTEM_MASSES["Sun"],
                        self.SOLAR_SYSTEM_MASSES["Mercury"],
                        self.SOLAR_SYSTEM_MASSES["Venus"],
                        self.SOLAR_SYSTEM_MASSES["Earth"],
                        self.SOLAR_SYSTEM_MASSES["Mars"],
                        self.SOLAR_SYSTEM_MASSES["Jupiter"],
                        self.SOLAR_SYSTEM_MASSES["Saturn"],
                        self.SOLAR_SYSTEM_MASSES["Uranus"],
                        self.SOLAR_SYSTEM_MASSES["Neptune"],
                        self.SOLAR_SYSTEM_MASSES["Pluto"],
                        self.SOLAR_SYSTEM_MASSES["Ceres"],
                        self.SOLAR_SYSTEM_MASSES["Vesta"],
                    ]

                    R_CM = (
                        1
                        / np.sum(self.m)
                        * (
                            self.m[0] * np.array(self.SOLAR_SYSTEM_POS["Sun"])
                            + self.m[1] * np.array(self.SOLAR_SYSTEM_POS["Mercury"])
                            + self.m[2] * np.array(self.SOLAR_SYSTEM_POS["Venus"])
                            + self.m[3] * np.array(self.SOLAR_SYSTEM_POS["Earth"])
                            + self.m[4] * np.array(self.SOLAR_SYSTEM_POS["Mars"])
                            + self.m[5] * np.array(self.SOLAR_SYSTEM_POS["Jupiter"])
                            + self.m[6] * np.array(self.SOLAR_SYSTEM_POS["Saturn"])
                            + self.m[7] * np.array(self.SOLAR_SYSTEM_POS["Uranus"])
                            + self.m[8] * np.array(self.SOLAR_SYSTEM_POS["Neptune"])
                            + self.m[9] * np.array(self.SOLAR_SYSTEM_POS["Pluto"])
                            + self.m[10] * np.array(self.SOLAR_SYSTEM_POS["Ceres"])
                            + self.m[11] * np.array(self.SOLAR_SYSTEM_POS["Vesta"])
                        )
                    )

                    V_CM = (
                        1
                        / np.sum(self.m)
                        * (
                            self.m[0] * np.array(self.SOLAR_SYSTEM_VEL["Sun"])
                            + self.m[1] * np.array(self.SOLAR_SYSTEM_VEL["Mercury"])
                            + self.m[2] * np.array(self.SOLAR_SYSTEM_VEL["Venus"])
                            + self.m[3] * np.array(self.SOLAR_SYSTEM_VEL["Earth"])
                            + self.m[4] * np.array(self.SOLAR_SYSTEM_VEL["Mars"])
                            + self.m[5] * np.array(self.SOLAR_SYSTEM_VEL["Jupiter"])
                            + self.m[6] * np.array(self.SOLAR_SYSTEM_VEL["Saturn"])
                            + self.m[7] * np.array(self.SOLAR_SYSTEM_VEL["Uranus"])
                            + self.m[8] * np.array(self.SOLAR_SYSTEM_VEL["Neptune"])
                            + self.m[9] * np.array(self.SOLAR_SYSTEM_VEL["Pluto"])
                            + self.m[10] * np.array(self.SOLAR_SYSTEM_VEL["Ceres"])
                            + self.m[11] * np.array(self.SOLAR_SYSTEM_VEL["Vesta"])
                        )
                    )

                    R1 = np.array(self.SOLAR_SYSTEM_POS["Sun"] - R_CM)
                    R2 = np.array(self.SOLAR_SYSTEM_POS["Mercury"] - R_CM)
                    R3 = np.array(self.SOLAR_SYSTEM_POS["Venus"] - R_CM)
                    R4 = np.array(self.SOLAR_SYSTEM_POS["Earth"] - R_CM)
                    R5 = np.array(self.SOLAR_SYSTEM_POS["Mars"] - R_CM)
                    R6 = np.array(self.SOLAR_SYSTEM_POS["Jupiter"] - R_CM)
                    R7 = np.array(self.SOLAR_SYSTEM_POS["Saturn"] - R_CM)
                    R8 = np.array(self.SOLAR_SYSTEM_POS["Uranus"] - R_CM)
                    R9 = np.array(self.SOLAR_SYSTEM_POS["Neptune"] - R_CM)
                    R10 = np.array(self.SOLAR_SYSTEM_POS["Pluto"] - R_CM)
                    R11 = np.array(self.SOLAR_SYSTEM_POS["Ceres"] - R_CM)
                    R12 = np.array(self.SOLAR_SYSTEM_POS["Vesta"] - R_CM)

                    V1 = np.array(self.SOLAR_SYSTEM_VEL["Sun"] - V_CM)
                    V2 = np.array(self.SOLAR_SYSTEM_VEL["Mercury"] - V_CM)
                    V3 = np.array(self.SOLAR_SYSTEM_VEL["Venus"] - V_CM)
                    V4 = np.array(self.SOLAR_SYSTEM_VEL["Earth"] - V_CM)
                    V5 = np.array(self.SOLAR_SYSTEM_VEL["Mars"] - V_CM)
                    V6 = np.array(self.SOLAR_SYSTEM_VEL["Jupiter"] - V_CM)
                    V7 = np.array(self.SOLAR_SYSTEM_VEL["Saturn"] - V_CM)
                    V8 = np.array(self.SOLAR_SYSTEM_VEL["Uranus"] - V_CM)
                    V9 = np.array(self.SOLAR_SYSTEM_VEL["Neptune"] - V_CM)
                    V10 = np.array(self.SOLAR_SYSTEM_VEL["Pluto"] - V_CM)
                    V11 = np.array(self.SOLAR_SYSTEM_VEL["Ceres"] - V_CM)
                    V12 = np.array(self.SOLAR_SYSTEM_VEL["Vesta"] - V_CM)

                    self.x = np.array(
                        [R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12]
                    )
                    self.v = np.array(
                        [V1, V2, V3, V4, V5, V6, V7, V8, V9, V10, V11, V12]
                    )
                    self.objects_count = 12
                    self.objs_name = [
                        "Sun",
                        "Mercury",
                        "Venus",
                        "Earth",
                        "Mars",
                        "Jupiter",
                        "Saturn",
                        "Uranus",
                        "Neptune",
                        "Pluto",
                        "Ceres",
                        "Vesta",
                    ]

        # Prevent the error message from numba package:
        # "Encountered the use of a type that is scheduled for deprecation: type 'reflected list' found for argument 'm' of function '...'."
        self.m = nb.typed.List(self.m)

    def simulation(self):
        print("Simulating the system...")
        start = timeit.default_timer()

        # Initializing
        if self.integrator in ["euler", "euler_cromer", "rk4", "leapfrog"]:
            self.npts = int(np.floor((self.tf - self.t0) / self.dt)) + 1
            self.sol_state = np.zeros((self.npts, self.objects_count * 3 * 2))
            self.sol_state[0] = np.concatenate(
                (
                    np.reshape(self.x, self.objects_count * 3),
                    np.reshape(self.v, self.objects_count * 3),
                )
            )
            self.sol_time = np.linspace(
                self.t0, self.t0 + self.dt * (self.npts - 1), self.npts
            )

        progress_bar = rich.progress.Progress(
            rich.progress.BarColumn(),
            rich.progress.TextColumn("[green]{task.percentage:>3.0f}%"),
            rich.progress.TextColumn("•"),
            rich.progress.TimeElapsedColumn(),
            rich.progress.TextColumn("•"),
            rich.progress.TimeRemainingColumn(),
        )

        with progress_bar as pb:
            match self.integrator:
                case "euler":
                    for count in pb.track(range(self.npts - 1)):
                        self.a = acceleration(
                            self.objects_count, self.x, self.m, self.G
                        )
                        self.x, self.v = euler(self.x, self.v, self.a, self.dt)
                        self.sol_state[count + 1] = np.concatenate(
                            (
                                np.reshape(self.x, self.objects_count * 3),
                                np.reshape(self.v, self.objects_count * 3),
                            )
                        )
                case "euler_cromer":
                    for count in pb.track(range(self.npts - 1)):
                        self.a = acceleration(
                            self.objects_count, self.x, self.m, self.G
                        )
                        self.x, self.v = euler_cromer(self.x, self.v, self.a, self.dt)
                        self.sol_state[count + 1] = np.concatenate(
                            (
                                np.reshape(self.x, self.objects_count * 3),
                                np.reshape(self.v, self.objects_count * 3),
                            )
                        )

                case "rk4":
                    for count in pb.track(range(self.npts - 1)):
                        self.x, self.v = rk4(
                            self.objects_count,
                            self.x,
                            self.v,
                            self.m,
                            self.G,
                            self.dt,
                        )
                        self.sol_state[count + 1] = np.concatenate(
                            (
                                np.reshape(self.x, self.objects_count * 3),
                                np.reshape(self.v, self.objects_count * 3),
                            )
                        )

                case "leapfrog":
                    self.a = acceleration(self.objects_count, self.x, self.m, self.G)
                    for count in pb.track(range(self.npts - 1)):
                        self.x, self.v, self.a = leapfrog(
                            self.objects_count,
                            self.x,
                            self.v,
                            self.a,
                            self.m,
                            self.G,
                            self.dt,
                        )
                        self.sol_state[count + 1] = np.concatenate(
                            (
                                np.reshape(self.x, self.objects_count * 3),
                                np.reshape(self.v, self.objects_count * 3),
                            )
                        )

                case "rkf45" | "dopri" | "dverk" | "rkf78":
                    (
                        self.power,
                        self.power_test,
                        self.coeff,
                        self.weights,
                        self.weights_test,
                    ) = butcher_tableaus_rk(self.order)
                    self.a = acceleration(self.objects_count, self.x, self.m, self.G)
                    self.initial_dt = initial_time_step_rk_embedded(
                        self.objects_count,
                        self.power,
                        self.x,
                        self.v,
                        self.a,
                        self.m,
                        self.G,
                        self.tolerance,
                        self.tolerance,
                    )
                    self.sol_state, self.sol_time = self.rk_embedded(
                        pb,
                        self.objects_count,
                        self.x,
                        self.v,
                        self.m,
                        self.G,
                        self.tf,
                        self.initial_dt,
                        self.power,
                        self.power_test,
                        self.coeff,
                        self.weights,
                        self.weights_test,
                        self.tolerance,
                        self.tolerance,
                    )

        stop = timeit.default_timer()
        print(f"Run time: {stop - start:.3f} s")
        print("")

    def trim_data(self):
        while True:
            try:
                trim_size = int(input("Enter desired number of lines: "))
                if trim_size >= len(self.sol_time):
                    raise ValueError
                else:
                    break
            except ValueError:
                print("Invalid input! Please try again.")
                pass 
            
        self.trim_size = math.floor(len(self.sol_time) / math.ceil(len(self.sol_time) / trim_size))
        if len(self.sol_time) % self.trim_size == 0:
            self.trim_size += 1
        self.trimmed_sol_time = np.zeros(self.trim_size)
        self.trimmed_sol_state = np.zeros((self.trim_size, self.objects_count * 3 * 2))

        j = 0
        for i in range(len(self.sol_time)):
            if i % math.ceil(len(self.sol_time) / self.trim_size) == 0:
                self.trimmed_sol_time[j] = self.sol_time[i]
                self.trimmed_sol_state[j] = self.sol_state[i]
                j += 1

        if self.trimmed_sol_time[-1] != self.sol_time[-1]:
            self.trimmed_sol_time[-1] = self.sol_time[-1]
            self.trimmed_sol_state[-1] = self.sol_state[-1]
        
        print(f"Trimmed data size = {len(self.trimmed_sol_time)}")

        self.sol_time = self.trimmed_sol_time
        self.sol_state = self.trimmed_sol_state

    def compute_energy(self):
        """
        Compute the total energy using the sol_state array
        """
        print("Computing energy...")
        self.energy = np.zeros(len(self.sol_state))
        self.progress_percentage = 0
        self.npts = len(self.sol_state)

        progress_bar = rich.progress.Progress(
            rich.progress.BarColumn(),
            rich.progress.TextColumn("[green]{task.percentage:>3.0f}%"),
            rich.progress.TextColumn("•"),
            rich.progress.TimeElapsedColumn(),
            rich.progress.TextColumn("•"),
            rich.progress.TimeRemainingColumn(),
        )

        start = timeit.default_timer()
        with progress_bar as pb:
            for count in pb.track(range(self.npts), description=""):
                x = self.sol_state[count]
                for i in range(self.objects_count):
                    # KE
                    self.energy[count] += (
                        0.5
                        * self.m[i]
                        * np.linalg.norm(
                            x[
                                (self.objects_count + i)
                                * 3 : (self.objects_count + 1 + i)
                                * 3
                            ]
                        )
                        ** 2
                    )
                    # PE
                    for j in range(self.objects_count):
                        if i < j:
                            self.energy[count] -= (
                                self.G
                                * self.m[i]
                                * self.m[j]
                                / np.linalg.norm(
                                    x[i * 3 : (i + 1) * 3] - x[j * 3 : (j + 1) * 3]
                                )
                            )

        stop = timeit.default_timer()
        print(f"Run time: {(stop - start):.3f} s")
        print("")

    def save_result(self, is_compute_energy):
        """
        Save the result in a csv file
        Unit: Solar masses, AU, day
        Format: time, total energy, x1, y1, z1, x2, y2, z2, ... vx1, vy1, vz1, vx2, vy2, vz2, ...
        """
        print("Storing simulation results...")
        file_path = Path(str(Path(__file__).parent) + "/results/")
        file_path.mkdir(parents=True, exist_ok=True)
        if self.unit == "years":
            self.tf /= 365.24
        file_path = Path(
            str(Path(__file__).parent)
            + "/results/"
            + str(datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S"))
            + f"_{self.system}_"
            + f"{self.tf}{self.unit[0]}_"
            + f"{self.integrator}"
            + ".csv"
        )

        progress_bar = rich.progress.Progress(
            rich.progress.BarColumn(),
            rich.progress.TextColumn("[green]{task.percentage:>3.0f}%"),
            rich.progress.TextColumn("•"),
            rich.progress.TimeElapsedColumn(),
            rich.progress.TextColumn("•"),
            rich.progress.TimeRemainingColumn(),
        )
        with progress_bar as pb:
            with open(file_path, "w", newline="") as file:
                writer = csv.writer(file)
                for count in pb.track(range(len(self.sol_time))):
                    if is_compute_energy:
                        row = np.insert(self.sol_state[count], 0, self.energy[count])
                        row = np.insert(row, 0, self.sol_time[count])
                    else:
                        row = np.insert(self.sol_state[count], 0, 0)
                        row = np.insert(row, 0, self.sol_time[count])
                    writer.writerow(row.tolist())

        print(f"Storing completed. Please check {file_path}")
        print("")

    def rk_embedded(
        self,
        progress_bar,
        objects_count: int,
        x,
        v,
        m,
        G,
        tf: float,
        initial_dt,
        power,
        power_test,
        coeff,
        weights,
        weights_test,
        abs_tolerance: float,
        rel_tolerance: float,
    ):
        """
        Perform simulation using rk_embedded methods
        Modified for plotting

        :return: sol_state, sol_time
        :rtype: numpy.array
        """
        # Initializing
        t = 0.0
        dt = initial_dt
        stages = len(weights)
        min_power = min([power, power_test])
        error_estimation_delta_weights = weights - weights_test

        # Safety factors for step-size control:
        safety_fac_max = 6.0
        safety_fac_min = 0.33
        safety_fac = 0.38 ** (1.0 / (1.0 + min_power))

        # Initialize vk and xk
        vk = np.zeros((stages, objects_count, 3))
        xk = np.zeros((stages, objects_count, 3))

        # Allocate for dense output:
        npts = 100000
        sol_state = np.zeros((npts, objects_count * 2 * 3))
        sol_time = np.zeros(npts)

        # Initial values
        sol_state[0] = np.concatenate(
            (np.reshape(x, objects_count * 3), np.reshape(v, objects_count * 3))
        )
        sol_time[0] = t

        # Launch integration:
        count = 0
        task = progress_bar.add_task("", total=tf)
        while True:
            # Calculate xk and vk
            vk[0] = acceleration(objects_count, x, m, G)
            xk[0] = np.copy(v)
            for stage in range(1, stages):
                temp_v = np.zeros((objects_count, 3))
                temp_x = np.zeros((objects_count, 3))
                for j in range(stage):
                    temp_v += coeff[stage - 1][j] * vk[j]
                    temp_x += coeff[stage - 1][j] * xk[j]
                vk[stage] = acceleration(objects_count, x + dt * temp_x, m, G)
                xk[stage] = v + dt * temp_v

            # Calculate x_1, v_1 and also delta x, delta v for error estimation
            temp_v = np.zeros((objects_count, 3))
            temp_x = np.zeros((objects_count, 3))
            error_estimation_delta_x = np.zeros((objects_count, 3))
            error_estimation_delta_v = np.zeros((objects_count, 3))
            for stage in range(stages):
                temp_v += weights[stage] * vk[stage]
                temp_x += weights[stage] * xk[stage]
                error_estimation_delta_v += (
                    error_estimation_delta_weights[stage] * vk[stage]
                )
                error_estimation_delta_x += (
                    error_estimation_delta_weights[stage] * xk[stage]
                )
            v_1 = v + dt * temp_v
            x_1 = x + dt * temp_x
            error_estimation_delta_v *= dt
            error_estimation_delta_x *= dt

            # Error calculation
            tolerance_scale_v = (
                abs_tolerance + np.maximum(np.abs(v), np.abs(v_1)) * rel_tolerance
            )
            tolerance_scale_x = (
                abs_tolerance + np.maximum(np.abs(x), np.abs(x_1)) * rel_tolerance
            )

            # Sum up all the elements of x/tol and v/tol, square and divide by the total number of elements
            sum = np.sum(
                np.square(error_estimation_delta_x / tolerance_scale_x)
            ) + np.sum(np.square(error_estimation_delta_v / tolerance_scale_v))
            error = np.sqrt(sum / (objects_count * 3 * 2))

            if error <= 1 or dt == tf * 1e-12:
                t += dt
                x = x_1
                v = v_1
                count += 1

                # Store step:
                sol_state[count] = np.concatenate(
                    (np.reshape(x, objects_count * 3), np.reshape(v, objects_count * 3))
                )
                sol_time[count] = t
                progress_bar.update(task, advance=dt)

                # Check buffer size and extend if needed :
                if (count + 1) == len(sol_state):
                    sol_state = np.concatenate(
                        (sol_state, np.zeros((npts, objects_count * 2 * 3)))
                    )
                    sol_time = np.concatenate((sol_time, np.zeros(npts)))

            dt_new = dt * safety_fac / error ** (1.0 / (1.0 + min_power))
            # Prevent dt to be too small or too large relative to the last time step
            if dt_new > safety_fac_max * dt:
                dt = safety_fac_max * dt
            elif dt_new < safety_fac_min * dt:
                dt = safety_fac_min * dt
            elif dt_new / tf < 1e-12:
                dt = tf * 1e-12
            else:
                dt = dt_new

            # Correct overshooting:
            if t + dt > tf:
                dt = tf - t

            if t >= tf:
                progress_bar.stop()
                return sol_state[0 : count + 1], sol_time[0 : count + 1]


# Note: jit cannot works on functions inside a class
@nb.njit
def acceleration(objects_count, x, m, G):
    """
    Calculate acceleration by a = - GM/r^3 vec{r}
    """
    # Allocate memory
    temp_a = np.zeros((objects_count * objects_count, 3))

    # Calculations
    for j in range(objects_count):
        for k in range(j + 1, objects_count):
            R = x[j] - x[k]
            R_norm = np.linalg.norm(R)
            temp_value = G * R / (R_norm * R_norm * R_norm)
            temp_a[j * objects_count + k] = -temp_value * m[k]
            temp_a[k * objects_count + j] = temp_value * m[j]

    temp_a = temp_a.reshape((objects_count, objects_count, 3))
    a = np.sum(temp_a, axis=1)

    return a


@nb.njit
def euler(x, v, a, dt):
    return x + v * dt, v + a * dt


@nb.njit
def euler_cromer(x, v, a, dt):
    v = v + a * dt
    x = x + v * dt
    return x, v


@nb.njit
def rk4(objects_count, x, v, m, G, dt):
    vk1 = acceleration(objects_count, x, m, G)
    xk1 = v

    vk2 = acceleration(objects_count, x + 0.5 * xk1 * dt, m, G)
    xk2 = v + 0.5 * vk1 * dt

    vk3 = acceleration(objects_count, x + 0.5 * xk2 * dt, m, G)
    xk3 = v + 0.5 * vk2 * dt

    vk4 = acceleration(objects_count, x + xk3 * dt, m, G)
    xk4 = v + vk3 * dt

    v = v + dt * (vk1 + 2 * vk2 + 2 * vk3 + vk4) / 6.0
    x = x + dt * (xk1 + 2 * xk2 + 2 * xk3 + xk4) / 6.0

    return x, v


@nb.njit
def leapfrog(objects_count, x, v, a, m, dt, G):
    a_0 = a
    x = x + v * dt + a_0 * 0.5 * dt * dt
    a_1 = acceleration(objects_count, x, m, G)
    v = v + (a_0 + a_1) * 0.5 * dt

    return x, v, a_1


@nb.njit
def initial_time_step_rk_embedded(
    objects_count: int,
    power: int,
    x,
    v,
    a,
    m,
    G,
    abs_tolerance: float,
    rel_tolerance: float,
) -> float:
    """
    Calculate the initial time step for embedded rk method
    Reference: Moving Planets Around: An Introduction to N-Body Simulations Applied to Exoplanetary Systems
    Chapter 6, Page 92 - 94
    """
    tolerance_scale_x = abs_tolerance + rel_tolerance * np.abs(x)
    tolerance_scale_v = abs_tolerance + rel_tolerance * np.abs(v)
    sum_1 = np.sum(np.square(x / tolerance_scale_x)) + np.sum(
        np.square(v / tolerance_scale_v)
    )
    sum_0 = np.sum(np.square(v / tolerance_scale_x)) + np.sum(
        np.square(a / tolerance_scale_v)
    )
    d_1 = np.sqrt(sum_1 / (objects_count * 3 * 2))
    d_0 = np.sqrt(sum_0 / (objects_count * 3 * 2))

    if d_0 < 1e-5 or d_1 < 1e-5:
        dt_0 = 1e-4
    else:
        dt_0 = d_0 / d_1

    x_1 = x + (dt_0 / 100) * v
    v_1 = v + (dt_0 / 100) * a
    a_1 = acceleration(objects_count, x_1, m, G)

    # Calculate d_2 to measure how much the derivatives have changed.
    sum_2 = np.sum(np.square((v_1 - v) / tolerance_scale_x)) + np.sum(
        np.square((a_1 - a) / tolerance_scale_v)
    )
    d_2 = np.sqrt(sum_2 / (objects_count * 3 * 2)) / dt_0

    if max(d_1, d_2) <= 1e-15:
        dt_1 = max([1e-6, dt_0 * 1e-3])
    else:
        dt_1 = (0.01 / max(d_1, d_2)) ** (1.0 / (1.0 + power))
    dt = min([100 * dt_0, dt_1])

    return dt


@nb.njit
def butcher_tableaus_rk(order):
    """
    Butcher tableaus for embedded rk

    Reference: Moving Planets Around: An Introduction to N-Body Simulations Applied to Exoplanetary Systems
    Chapter 6, Page 100 - 101

    :raise ValueError: If order is not in [45, 54, 78, 65]
    :return: power, power_test, coeff, weights, weights_test
    :rtype: numpy.array
    """
    # Select integrator
    # 45) Runge-Kutta-Fehleberg 4(5)
    # 54) Dormand-Prince 5(4)
    # 78) Runge-Kutta-Fehlberg 7(8)
    # 65) Verner's method 6(5), DVERK

    match order:
        # RUNGE-KUTTA-FEHLBERG 4(5)
        case 45:
            # Order
            power = 4
            power_test = 5
            # nodes = np.array([1.0 / 4.0, 3.0 / 8.0, 12.0 / 13.0, 1.0, 0.5])
            coeff = np.array(
                [
                    [1.0 / 4.0, 0.0, 0.0, 0.0, 0.0],
                    [3.0 / 32.0, 9.0 / 32.0, 0.0, 0.0, 0.0],
                    [1932.0 / 2197.0, -7200.0 / 2197.0, 7296.0 / 2197.0, 0.0, 0.0],
                    [439.0 / 216.0, -8.0, 3680.0 / 513.0, -845.0 / 4104.0, 0.0],
                    [-8.0 / 27.0, 2.0, -3544.0 / 2565.0, 1859.0 / 4104.0, -11.0 / 40.0],
                ]
            )

            weights = np.array(
                [25.0 / 216.0, 0.0, 1408.0 / 2565.0, 2197.0 / 4104.0, -0.2, 0.0]
            )
            weights_test = np.array(
                [
                    16.0 / 135.0,
                    0.0,
                    6656.0 / 12825.0,
                    28561.0 / 56430.0,
                    -9.0 / 50.0,
                    2.0 / 55.0,
                ]
            )

        # DORMAND-PRINCE 5(4)
        case 54:
            # order
            power = 5
            power_test = 4
            # nodes = np.array([1.0 / 5.0, 3.0 / 10.0, 4.0 / 5.0, 8.0 / 9.0, 1.0, 1.0])
            coeff = np.array(
                [
                    [1.0 / 5.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                    [3.0 / 40.0, 9.0 / 40.0, 0.0, 0.0, 0.0, 0.0],
                    [44.0 / 45.0, -56.0 / 15.0, 32.0 / 9.0, 0.0, 0.0, 0.0],
                    [
                        19372.0 / 6561.0,
                        -25360.0 / 2187.0,
                        64448.0 / 6561.0,
                        -212.0 / 729.0,
                        0.0,
                        0.0,
                    ],
                    [
                        9017.0 / 3168.0,
                        -355.0 / 33.0,
                        46732.0 / 5247.0,
                        49.0 / 176.0,
                        -5103.0 / 18656.0,
                        0.0,
                    ],
                    [
                        35.0 / 384.0,
                        0.0,
                        500.0 / 1113.0,
                        125.0 / 192.0,
                        -2187.0 / 6784.0,
                        11.0 / 84.0,
                    ],
                ]
            )
            weights = np.array(
                [
                    35.0 / 384.0,
                    0.0,
                    500.0 / 1113.0,
                    125.0 / 192.0,
                    -2187.0 / 6784.0,
                    11.0 / 84.0,
                    0.0,
                ]
            )
            weights_test = np.array(
                [
                    5179.0 / 57600.0,
                    0.0,
                    7571.0 / 16695.0,
                    393.0 / 640.0,
                    -92097.0 / 339200.0,
                    187.0 / 2100.0,
                    1.0 / 40.0,
                ]
            )

        # RUNGE-KUTTA-FEHLBERG 7(8)
        case 78:
            # Order
            power = 7
            power_test = 8
            # nodes = np.array(
            #     [
            #         2.0 / 27.0,
            #         1.0 / 9.0,
            #         1.0 / 6.0,
            #         5.0 / 12.0,
            #         1.0 / 2.0,
            #         5.0 / 6.0,
            #         1.0 / 6.0,
            #         2.0 / 3.0,
            #         1.0 / 3.0,
            #         1.0,
            #         0.0,
            #         1.0,
            #     ]
            # )
            coeff = np.array(
                [
                    [2.0 / 27.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                    [
                        1.0 / 36.0,
                        1.0 / 12.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        1.0 / 24.0,
                        0.0,
                        1.0 / 8.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        5.0 / 12.0,
                        0.0,
                        -25.0 / 16.0,
                        25.0 / 16.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        1.0 / 20.0,
                        0.0,
                        0.0,
                        1.0 / 4.0,
                        1.0 / 5.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        -25.0 / 108.0,
                        0.0,
                        0.0,
                        125.0 / 108.0,
                        -65.0 / 27.0,
                        125.0 / 54.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        31.0 / 300.0,
                        0.0,
                        0.0,
                        0.0,
                        61.0 / 225.0,
                        -2.0 / 9.0,
                        13.0 / 900.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        2.0,
                        0.0,
                        0.0,
                        -53.0 / 6.0,
                        704.0 / 45.0,
                        -107.0 / 9.0,
                        67.0 / 90.0,
                        3.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        -91.0 / 108.0,
                        0.0,
                        0.0,
                        23.0 / 108.0,
                        -976.0 / 135.0,
                        311.0 / 54.0,
                        -19.0 / 60.0,
                        17.0 / 6.0,
                        -1.0 / 12.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        2383.0 / 4100.0,
                        0.0,
                        0.0,
                        -341.0 / 164.0,
                        4496.0 / 1025.0,
                        -301.0 / 82.0,
                        2133.0 / 4100.0,
                        45.0 / 82.0,
                        45.0 / 164.0,
                        18.0 / 41.0,
                        0.0,
                        0.0,
                    ],
                    [
                        3.0 / 205.0,
                        0.0,
                        0.0,
                        0.0,
                        0.0,
                        -6.0 / 41.0,
                        -3.0 / 205.0,
                        -3.0 / 41.0,
                        3.0 / 41.0,
                        6.0 / 41.0,
                        0.0,
                        0.0,
                    ],
                    [
                        -1777.0 / 4100.0,
                        0.0,
                        0.0,
                        -341.0 / 164.0,
                        4496.0 / 1025.0,
                        -289.0 / 82.0,
                        2193.0 / 4100.0,
                        51.0 / 82.0,
                        33.0 / 164.0,
                        19.0 / 41.0,
                        0.0,
                        1.0,
                    ],
                ]
            )

            weights = np.array(
                [
                    41.0 / 840.0,
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    34.0 / 105.0,
                    9.0 / 35.0,
                    9.0 / 35.0,
                    9.0 / 280.0,
                    9.0 / 280.0,
                    41.0 / 840.0,
                    0.0,
                    0.0,
                ]
            )
            weights_test = np.array(
                [
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    0.0,
                    34.0 / 105.0,
                    9.0 / 35.0,
                    9.0 / 35.0,
                    9.0 / 280.0,
                    9.0 / 280.0,
                    0.0,
                    41.0 / 840.0,
                    41.0 / 840.0,
                ]
            )

        # VERNER 6(5) DVERK
        case 65:
            # Order
            power = 6
            power_test = 7
            # nodes = np.array(
            #     [1.0 / 6.0, 4.0 / 15.0, 2.0 / 3.0, 5.0 / 6.0, 1.0, 1.0 / 15.0, 1.0]
            # )
            coeff = np.array(
                [
                    [1.0 / 6.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                    [4.0 / 75.0, 16.0 / 75.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                    [5.0 / 6.0, -8.0 / 3.0, 5.0 / 2.0, 0.0, 0.0, 0.0, 0.0],
                    [
                        -165.0 / 64.0,
                        55.0 / 6.0,
                        -425.0 / 64.0,
                        85.0 / 96.0,
                        0.0,
                        0.0,
                        0.0,
                    ],
                    [
                        12.0 / 5.0,
                        -8.0,
                        4015.0 / 612.0,
                        -11.0 / 36.0,
                        88.0 / 255.0,
                        0.0,
                        0.0,
                    ],
                    [
                        -8263.0 / 15000.0,
                        124.0 / 75.0,
                        -643.0 / 680.0,
                        -81.0 / 250.0,
                        2484.0 / 10625.0,
                        0.0,
                        0.0,
                    ],
                    [
                        3501.0 / 1720.0,
                        -300.0 / 43.0,
                        297275.0 / 52632.0,
                        -319.0 / 2322.0,
                        24068.0 / 84065.0,
                        0.0,
                        3850.0 / 26703.0,
                    ],
                ]
            )

            weights = np.array(
                [
                    3.0 / 40.0,
                    0.0,
                    875.0 / 2244.0,
                    23.0 / 72.0,
                    264.0 / 1955.0,
                    0.0,
                    125.0 / 11592.0,
                    43.0 / 616.0,
                ]
            )
            weights_test = np.array(
                [
                    13.0 / 160.0,
                    0.0,
                    2375.0 / 5984.0,
                    5.0 / 16.0,
                    12.0 / 85.0,
                    3.0 / 44.0,
                    0.0,
                    0.0,
                ]
            )

        case _:
            raise ValueError

    return power, power_test, coeff, weights, weights_test
